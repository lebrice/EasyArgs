import argparse
import dataclasses
import enum
import logging
from typing import *
from typing import cast

import inspect
from .. import docstring, utils
from ..utils import Dataclass, DataclassType

logger = logging.getLogger(__name__)


@dataclasses.dataclass
class FieldWrapper:
    field: dataclasses.Field
    parent: Any = dataclasses.field(repr=False)
    _required: Optional[bool] = None
    _docstring: Optional[docstring.AttributeDocString] = None
    _multiple: bool = False
    _defaults: Optional[Union[Any,List[Any]]] = None
    _help: Optional[str] = None
    _metavar: Optional[str] = None
    _default: Optional[Any] = None
    # the argparse-related options:
    _arg_options: Dict[str, Any] = dataclasses.field(init=False, default_factory=dict)
    
    def __post_init__(self):
        try:
            self._docstring = docstring.get_attribute_docstring(self.parent.dataclass, self.field.name)
        except (SystemExit, Exception) as e:
            logger.debug(f"Couldn't find attribute docstring: {e}")
            self._docstring = docstring.AttributeDocString()

    @property
    def arg_options(self) -> Dict[str, Any]:
        """Dictionary of values to be passed to the `add_argument` method.
        
        The main feature of this package is to infer these arguments 
        automatically using features of the built-in `dataclasses` package, as
        well as Python's type annotations.

        By passing additional keyword arguments to the `field()`
        function, the autogenerated arguments can be overwriten,
        giving access to all of the usual argparse features know and love.

        NOTE: When passing an `action` keyword argument, we remove all the actions
        that aren't required by the Action class constructor.
        For example, when specifying a custom `action` like "store_true" or
        "store_false", the `type` argument autogenerated here shouldn't be
        passed to the constructor.

        Returns
        -------
        Dict[str, Any]
            A dictionary of options, possibly updated with the  keyword arguments passed to the `field()` method.
        """
        if self._arg_options:
            return self._arg_options
        # get the auto-generated options:
        options = self._get_arg_options()
        # overwrite the auto-generated options with the manually passed ones:
        options.update(self.custom_arg_options)
        # only keep the arguments used by the Action constructor.
        self._arg_options = only_keep_action_args(options)
        return self._arg_options

    def __call__(self,
                 parser: argparse.ArgumentParser,
                 namespace: argparse.Namespace,
                 values: Any,
                 option_string: Optional[str] = None):
        """Immitates a custom Action, which sets the corresponding value from
        `values` at the right destination in the `constructor_arguments` of the
        parser.
        
        TODO: Could be simplified by removing unused arguments, if we decide
        that there is no real value in implementing a CustomAction class.

        Args:
            parser (argparse.ArgumentParser): the `simple_parsing.ArgumentParser` used.
            namespace (argparse.Namespace): (unused).
            values (Any): The parsed values for the argument.
            option_string (Optional[str], optional): (unused). Defaults to None.
        """
        from simple_parsing import ArgumentParser
        parser = cast(ArgumentParser, parser)
        
        logger.info(f"__call__ of field for destinations {self.destinations}, Namespace: {namespace}, values: {values}")
        
        if self.multiple:
            values = self.duplicate_if_needed(values)
            logger.debug(f"(replicated the parsed values: '{values}')")
        else:
            values = [values]

        for destination, value in zip(self.destinations, values):
            parent_dest, attribute = utils.split_parent_and_child(destination)
            value = self.postprocess(value)
            logger.debug(f"setting value of {value} in constructor arguments of parent at key '{parent_dest}' and attribute '{attribute}'")
            parser.constructor_arguments[parent_dest][attribute] = value # type: ignore
            logger.info(f"Constructor arguments so far: {parser.constructor_arguments}")
    
    def duplicate_if_needed(self, parsed_values: Any) -> List[Any]:
        """Duplicates the passed argument values if needed, such that each instance gets a value.

        For example, if we expected 3 values for an argument, and a single value was passed,
        then we duplicate it so that each of the three instances get the same value.
        
        Args:
            parsed_values (Any): The parsed value(s)
        
        Raises:
            utils.InconsistentArgumentError: If the number of arguments passed is inconsistent (neither 1 or the number of instances)
        
        Returns:
            List[Any]: The list of parsed values, of the right length.
        """
        num_instances_to_parse = len(self.destinations)
        logger.debug(f"Duplicating raw values. num to parse: {num_instances_to_parse}")
        logger.debug(f"(raw) parsed values: '{parsed_values}'")
        
        assert self.multiple
        assert num_instances_to_parse > 1, "multiple is true but we're expected to instantiate only one instance"
        
        if utils.is_list(self.field.type) and isinstance(parsed_values, tuple):
            parsed_values = list(parsed_values)

        if not self.is_tuple and not self.is_list and isinstance(parsed_values, list):
            nesting_level = utils.get_nesting_level(parsed_values)
            if nesting_level == 2 and len(parsed_values) == 1 and len(parsed_values[0]) == num_instances_to_parse:
                return parsed_values[0]

        if not isinstance(parsed_values, (list, tuple)):
            parsed_values = [parsed_values]

        if len(parsed_values) == num_instances_to_parse:    
            return parsed_values
        elif len(parsed_values) == 1:
            return parsed_values * num_instances_to_parse
        else:
            raise utils.InconsistentArgumentError(
                f"The field '{self.name}' contains {len(parsed_values)} values, but either 1 or {num_instances_to_parse} values were expected."
            )
        return parsed_values

    def postprocess(self, raw_parsed_value: Any) -> Any:
        """Applies any conversions to the 'raw' parsed value before it is used in the constructor of the dataclass.
        
        Args:
            raw_parsed_value (Any): The 'raw' parsed value.
        
        Returns:
            Any: The processed value
        """
        if self.is_enum:
            logger.debug(f"field postprocessing for Enum field '{self.name}' with value: {raw_parsed_value}'")
            if isinstance(raw_parsed_value, str):
                raw_parsed_value = self.field.type[raw_parsed_value]
            return raw_parsed_value

        elif self.is_tuple:
            # argparse always returns lists by default. If the field was of a Tuple type, we just transform the list to a Tuple.
            if not isinstance(raw_parsed_value, tuple):
                return tuple(raw_parsed_value)

        elif self.is_bool:
            if raw_parsed_value is None and self.defaults is not None:
                logger.debug("value is None, returning opposite of default")
                return not self.defaults
            return raw_parsed_value

        elif self.is_list:
            return list(raw_parsed_value)

        elif self.is_subparser:
            return raw_parsed_value

        elif self.field.type not in utils.builtin_types:
            try:
                # if the field has a weird type, we try to call it directly.
                return self.field.type(raw_parsed_value)
            except Exception as e:
                logger.warning(
                    f"Unable to instantiate the field '{self.name}' of type '{self.field.type}' by using the type as a constructor. "
                    f"Returning the raw parsed value instead ({raw_parsed_value}, of type {type(raw_parsed_value)}). (Caught Exception: {e})"
                )
                return raw_parsed_value

        logger.debug(f"field postprocessing for field of type '{self.field.type}' and with value '{raw_parsed_value}'")
        return raw_parsed_value

       
    @property
    def multiple(self) -> bool:
        return self._multiple

    @multiple.setter
    def multiple(self, value: bool):
        if self._multiple != value:
            self.arg_options.clear()
        self._multiple = value
    
    @property
    def action(self) -> str:
        """Returns the `action` argument to be passed to `add_argument(...)`
        
        Returns
        -------
        str
            The action, if a custom action was supplied, else "store".
        """
        return self.custom_arg_options.get("action", "store")

    @property
    def custom_arg_options(self) -> Dict[str, Any]:
        """Custom argparse options that overwrite those in `arg_options`.
        
        Can be set by using the `field` function, passing in a keyword argument
        that would usually be passed to the parser.add_argument(
        *option_strings, **kwargs) method. 
        """
        return self.field.metadata.get("custom_args", {})

    @property
    def destinations(self) -> List[str]:
        return [parent_dest + "." + self.name for parent_dest in self.parent.destinations]

    @property
    def option_strings(self) -> List[str]:
        _option_strings = [f"--{self.prefix}{self.name}"]
        for alias in self.aliases:
            dashes: str = "--"
            name: str = alias
            if alias.startswith("--"):
                dashes = "--"
                name = alias[2:]
            elif alias.startswith("-"):
                dashes = "-"
                name = alias[1:]
            elif len(alias) == 1:
                dashes = "-"
            option = f"{dashes}{self.prefix}{name}"
            _option_strings.append(option)
        return _option_strings

    @property
    def prefix(self) -> str:
        return self.parent.prefix

    @property
    def aliases(self) -> List[str]:
        return self.field.metadata.get("aliases", [])

    @property
    def dest(self) -> str:
        """
        TODO: It doesn't make much sense to use `dest` here, since we ultimately don't care
        where the attribute will be stored in the Namespace, we just want to set a value in
        the constructor arguments in the parser!
        """
        lineage = []
        parent = self.parent
        while parent is not None:
            lineage.append(parent.attribute_name)
            parent = parent._parent
        lineage = list(reversed(lineage))
        lineage.append(self.name)
        _dest = ".".join(lineage)
        return _dest

    @property
    def nargs(self):
        return self.arg_options.get("nargs")

    @property
    def const(self):
        return self.arg_options.get("const")

    @property
    def defaults(self) -> Optional[Union[Any, List[Any]]]:
        """ Either a single default value, when parsing a single argument, or
        the list of default values, when this argument is reused multiple times.
        """
        if self.parent.defaults:
            # if the dataclass holding this field has a default value (either 
            # when passed  manually or by nesting), use those values.
            defaults = []
            for default in self.parent.defaults:
                parent_value = getattr(default, self.name)
                defaults.append(parent_value)
           
            if len(defaults) == 1 and not self.multiple:
                # if we only have one value, we use the value itself rather
                # than a list with one element.
                self.default = defaults[0]
                self._defaults = self.default
                return self.default
                defaults = default
                self.default = defaults[0]
            
            self._defaults = defaults
        else:
            self._defaults = self.default
            return self._defaults
        return self._defaults

    @defaults.setter
    def defaults(self, value: Any):
        self._defaults = value

    @property
    def default(self) -> Any:
        if self._default is not None:
            return self._default
        
        default = utils.default_value(self.field)
        if default is None:
            if self.action == "store_true":
                default = False
            elif self.action == "store_false":
                default = True
        self._default = default
        return default
    
    @default.setter
    def default(self, value: Any):
        self._default = value

    @property
    def type(self):
        return self.arg_options.get("type")

    @property
    def choices(self):
        return self.arg_options.get("choices")
    
    @property
    def required(self) -> bool:
        if self._required is not None:
            return self._required
        
        if self.action in {"store_true", "store_false"}:
            self._required = False
        elif self.parent and self.parent.required:
            self._required = True
        elif self.defaults is None:
            self._required = True
        # elif isinstance(self.defaults, list) and not self.defaults:
        #     self._required = True
        else:
            self._required = False
        return self._required


    @required.setter
    def required(self, value: bool):
        self._required = value

    @property
    def help(self) -> Optional[str]:
        if self._help is not None:
            return self._help
        if self._docstring is not None:
            if self._docstring.docstring_below:
                self._help = self._docstring.docstring_below
            elif self._docstring.comment_above:
                self._help = self._docstring.comment_above
            elif self._docstring.comment_inline:
                self._help = self._docstring.comment_inline
        return self._help

    @help.setter
    def help(self, value: str):
        self._help = value

    @property
    def metavar(self) -> Optional[str]:
        return self._metavar

    @metavar.setter
    def metavar(self, value: str):
        self._metavar = value

    @property
    def name(self) -> str:
        return self.field.name

    def _get_arg_options(self) -> Dict[str, Any]:
        if not self.field.init:
            return {}

        assert not dataclasses.is_dataclass(self.field.type), "Shouldn't have created a FieldWrapper for a dataclass in the first place!"
        assert not utils.is_tuple_or_list_of_dataclasses(self.field.type), "Shouldn't have created a FieldWrapper for a list of dataclasses in the first place!"

        _arg_options: Dict[str, Any] = {}
        # TODO: should we explicitly use `str` whenever the type isn't a builtin type? or try to use it as a constructor?
        _arg_options["type"] = self.field.type
        _arg_options["help"] = self.help
        _arg_options["default"] = self.defaults
        _arg_options["required"] = self.required
        _arg_options["dest"] = self.dest
        
        if self.is_enum:
            # we actually parse enums as string, and convert them back to enums in the `process` method.
            _arg_options["choices"] = list(e.name for e in self.field.type)
            _arg_options["type"] = str 
            # if the default value is an Enum, we convert it to a string.
            if self.defaults:
                enum_to_str = lambda e: e.name if isinstance(e, enum.Enum) else e
                if not self.multiple:                
                    _arg_options["default"] = enum_to_str(self.defaults)
                else:
                    _arg_options["default"] = [enum_to_str(default) for default in self.defaults]
        
        elif self.is_list:
            # Check if typing.List or typing.Tuple was used as an annotation, in which case we can automatically convert items to the desired item type.
            T = utils.get_argparse_type_for_container(self.field.type)
            logger.debug(f"Adding a List attribute '{self.name}' with items of type '{T}'")
            _arg_options["nargs"] = "*"
            _arg_options["type"] = T

            if self.multiple:
                _arg_options["type"] = utils._parse_multiple_containers(self.field.type)
                _arg_options["type"].__name__ = utils.get_type_name(self.field.type)

        elif self.is_tuple:
            T = utils.get_argparse_type_for_container(self.field.type)
            logging.debug(f"Adding a Tuple attribute '{self.name}' with items of type '{T}'")
            _arg_options["nargs"] = utils.get_container_nargs(self.field.type)
            _arg_options["type"] = utils._parse_container(self.field.type)

            if self.multiple:
                type_arguments = utils.get_type_arguments(self.field.type)
                _arg_options["type"] = utils._parse_multiple_containers(self.field.type)
                _arg_options["type"].__name__ = utils.get_type_name(self.field.type)
        
        elif self.field.type is bool:
            _arg_options["type"] = utils.str2bool
            if self.defaults is not None:
                _arg_options["nargs"] = "?"
            
        if self.multiple:
            if self.required:
                _arg_options["nargs"] = "+"
            else:
                _arg_options["nargs"] = "*"

        return _arg_options

    @property
    def is_list(self):
        return utils.is_list(self.field.type)
    
    @property
    def is_enum(self) -> bool:
        return utils.is_enum(self.field.type)

    @property
    def is_choice(self) -> bool:
        return bool(self.field.metadata) and "choices" in self.field.metadata

    @property
    def is_tuple(self) -> bool:
        return utils.is_tuple(self.field.type)
    
    @property
    def is_bool(self) -> bool:
        return utils.is_bool(self.field.type)
    
    @property
    def is_subparser(self) -> bool:
        return utils.is_subparser_field(self.field)
    
    @property
    def type_arguments(self) -> List[Type]:
        return utils.get_type_arguments(self.field.type)

    @property
    def subparsers_dict(self) -> Dict[str, Type]:
        if "subparsers" in self.field.metadata:
            return self.field.metadata["subparsers"]
        else:
            type_arguments = utils.get_type_arguments(self.field.type)
            return {
                dataclass_type.__name__.lower(): dataclass_type for dataclass_type in type_arguments
            }
    
    def add_subparsers(self, parser: argparse.ArgumentParser):
        if self.is_subparser:
            # add subparsers for each dataclass type in the field.
            subparsers = parser.add_subparsers(
                title=self.name,
                description=self.help,
                dest=self.dest
            )
            subparsers.required = True

            for subcommand, dataclass_type in self.subparsers_dict.items():
                subparser: ArgumentParser = subparsers.add_parser(subcommand) # type: ignore
                subparser.add_arguments(dataclass_type, dest=self.dest)



def only_keep_action_args(options: Dict[str, Any]) -> Dict[str, Any]:
    """Remove all the arguments in `options` that aren't required by the Action.
    
    Parameters
    ----------
    options : Dict[str, Any]
        A dictionary of options that would usually be passed to
        `add_arguments(*option_strings, **options)`.
    
    Returns
    -------
    Dict[str, Any]
        [description]
    """
    # get the custom action, if specified, else, the custom action of "store".

    action = options.get("action", "store")
    action_classes: Dict[str, Type[argparse.Action]] = {
        "store": argparse._StoreAction,                 # TODO: Test this.
        "store_const": argparse._StoreConstAction,      # TODO: Test this.
        "store_true": argparse._StoreTrueAction,        
        "store_false": argparse._StoreFalseAction,      
        "append": argparse._AppendAction,               # TODO: Test this.
        "append_const": argparse._AppendConstAction,    # TODO: Test this.
        "count": argparse._CountAction,                 # TODO: Test this.
        "help": argparse._HelpAction,                   # TODO: Test this.
        "version": argparse._VersionAction,             # TODO: Test this.
        "parsers": argparse._SubParsersAction,          # TODO: Test this.
    }
    if action not in action_classes:
        # the provided `action` is not a standard argparse-action.
        # We don't remove any of the provided options.
        return options

    # Remove all the keys that aren't needed by the action constructor:
    action_class = action_classes[action]
    argspec = inspect.getfullargspec(action_class)

    if argspec.varargs is not None or argspec.varkw is not None:
        # if the constructor takes variable arguments, pass all the options.
        logger.debug("Constructor takes var args. returning all options.")
        return options

    args_to_keep = argspec.args + ["action"]
    
    kept_options, deleted_options = utils.keep_keys(options, args_to_keep)
    if deleted_options:
        logger.warning(
            f"Warning: some auto-generated options were deleted, as they were "
            f"not required by the Action constructor: {deleted_options}."
        )
    logger.debug(f"Kept options: \t{kept_options.keys()}")
    logger.debug(f"Removed options: \t{deleted_options.keys()}")
    return kept_options